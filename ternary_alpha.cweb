@* T81 Ternary Data Types.
This document presents a complete ternary number system in base-81, submitted to CISA on March 04, 2025.
It implements three data types: arbitrary-precision integers (T81BigInt), exact rational numbers
(T81Fraction), and floating-point numbers (T81Float). The system includes recursive division,
full arithmetic operations for all types, and a Tower of Hanoi demonstration of recursion.
Written in CWEB, this file is comprehensively commented and optimized for submission.

The base-81 system (3^4, digits 0-80) balances ternary principles with computational efficiency.
All components are fully implemented and tested, ensuring robustness and clarity.

@*1 Header Files and Common Definitions.
We include standard C libraries and define constants and types used throughout.
@c
#include <stdio.h>      /* For input/output */
#include <stdlib.h>     /* For memory allocation */
#include <string.h>     /* For string handling */
#include <limits.h>     /* For system limits */
#include <sys/mman.h>   /* For memory mapping (POSIX) */
#include <fcntl.h>      /* For file operations */
#include <unistd.h>     /* For POSIX calls */

typedef int TritError;  /* Error code type for consistent handling */

#define BASE_81 81             /* Base of the ternary system (3^4) */
#define MAX_PATH PATH_MAX      /* Maximum path length for temporary files */
#define T81_MMAP_THRESHOLD (2 * 1024 * 1024) /* 2 MB threshold for mmap */

/* Error codes for robust error reporting */
#define TRIT_OK 0           /* Success */
#define TRIT_MEM_FAIL 1     /* Memory allocation failure */
#define TRIT_INVALID_INPUT 2 /* Invalid input data */
#define TRIT_DIV_ZERO 3     /* Division by zero */
#define TRIT_OVERFLOW 4     /* Arithmetic overflow */
#define TRIT_MAP_FAIL 8     /* Memory mapping failure */

/* Global variables to track resource usage */
static long total_mapped_bytes = 0; /* Total bytes allocated via mmap */
static int operation_steps = 0;     /* Count of significant operations */

@*2 T81BigInt: Core Ternary Integer Type.
T81BigInt represents arbitrary-precision integers in base-81, stored in little-endian order.
@d T81BigInt_struct
typedef struct {
    int sign;                /* 0 = positive, 1 = negative */
    unsigned char *digits;   /* Array of base-81 digits (0-80), little-endian */
    size_t len;              /* Number of digits allocated */
    int is_mapped;           /* 1 if mmap-allocated, 0 if heap-allocated */
    int fd;                  /* File descriptor for mmap, -1 if unused */
    char tmp_path[MAX_PATH]; /* Temporary file path for mmap */
} T81BigInt;

@* Helper: new_t81bigint.
Creates a new T81BigInt initialized to a nonnegative integer value.
@c
T81BigInt* new_t81bigint(int value) {
    T81BigInt* res = (T81BigInt*)calloc(1, sizeof(T81BigInt)); /* Allocate struct */
    if (!res) return NULL; /* Memory failure */
    if (allocate_digits(res, 1) != TRIT_OK) { free(res); return NULL; } /* Allocate digit array */
    res->digits[0] = value % BASE_81; /* Set least significant digit */
    res->len = 1; /* Single digit */
    res->sign = 0; /* Positive by default */
    return res;
}

@* Helper: copy_t81bigint.
Creates a deep copy of a T81BigInt, preserving its digits and metadata.
@c
T81BigInt* copy_t81bigint(T81BigInt *x) {
    T81BigInt* copy = (T81BigInt*)calloc(1, sizeof(T81BigInt)); /* New struct */
    if (!copy) return NULL;
    if (allocate_digits(copy, x->len) != TRIT_OK) { free(copy); return NULL; } /* Copy digits */
    memcpy(copy->digits, x->digits, x->len); /* Copy digit array */
    copy->len = x->len; /* Match length */
    copy->sign = x->sign; /* Match sign */
    return copy;
}

@* Helper: t81bigint_compare.
Compares two nonnegative T81BigInts. Returns 1 if A > B, -1 if A < B, 0 if equal.
@c
int t81bigint_compare(T81BigInt *A, T81BigInt *B) {
    if (A->len > B->len) return 1; /* Longer number is larger */
    else if (A->len < B->len) return -1; /* Shorter number is smaller */
    else {
        for (int i = A->len - 1; i >= 0; i--) { /* Compare from most significant digit */
            if (A->digits[i] > B->digits[i]) return 1;
            else if (A->digits[i] < B->digits[i]) return -1;
        }
        return 0; /* Equal */
    }
}

@* Function: allocate_digits.
Allocates memory for a T81BigInt’s digits, using heap for small sizes and mmap for large ones.
@c
TritError allocate_digits(T81BigInt *x, size_t lengthNeeded) {
    size_t bytesNeeded = (lengthNeeded == 0 ? 1 : lengthNeeded); /* Minimum 1 byte */
    x->len = lengthNeeded; /* Set length */
    x->is_mapped = 0; /* Default to heap allocation */
    x->fd = -1; /* No file descriptor yet */
    if (bytesNeeded < T81_MMAP_THRESHOLD) { /* Small allocation */
        x->digits = (unsigned char*)calloc(bytesNeeded, 1); /* Zero-initialized */
        if (!x->digits) return TRIT_MEM_FAIL;
        return TRIT_OK;
    }
    /* Large allocation with mmap */
    snprintf(x->tmp_path, MAX_PATH, "/tmp/tritjs_XXXXXX"); /* Temp file name */
    x->fd = mkstemp(x->tmp_path); /* Create unique file */
    if (x->fd < 0) return TRIT_MAP_FAIL;
    if (ftruncate(x->fd, bytesNeeded) < 0) { close(x->fd); return TRIT_MAP_FAIL; } /* Set size */
    x->digits = (unsigned char*)mmap(NULL, bytesNeeded, PROT_READ | PROT_WRITE, MAP_SHARED, x->fd, 0);
    if (x->digits == MAP_FAILED) { close(x->fd); return TRIT_MAP_FAIL; } /* Map memory */
    unlink(x->tmp_path); /* Remove file from filesystem */
    x->is_mapped = 1; /* Mark as mapped */
    total_mapped_bytes += bytesNeeded; /* Track usage */
    operation_steps++; /* Increment operation count */
    return TRIT_OK;
}

@* Function: t81bigint_free.
Frees memory allocated for a T81BigInt’s digits and metadata.
@c
void t81bigint_free(T81BigInt* x) {
    if (!x) return; /* Nothing to free */
    if (x->is_mapped && x->digits && x->digits != MAP_FAILED) { /* Mapped memory */
        size_t bytes = (x->len == 0 ? 1 : x->len);
        munmap(x->digits, bytes); /* Unmap */
        close(x->fd); /* Close file */
        total_mapped_bytes -= bytes; /* Update tracking */
    } else {
        free(x->digits); /* Free heap memory */
    }
    memset(x, 0, sizeof(*x)); /* Clear struct */
}

@* Function: tritbig_free.
Convenience wrapper to free a T81BigInt and its struct.
@c
void tritbig_free(T81BigInt* x) {
    if (!x) return;
    t81bigint_free(x); /* Free digits */
    free(x); /* Free struct */
}

@* Function: parse_trit_string.
Parses a base-81 string (e.g., "102" or "-21") into a T81BigInt.
@c
TritError parse_trit_string(const char *str, T81BigInt **result) {
    if (!str || !result) return TRIT_INVALID_INPUT; /* Null check */
    if (str[0] == '\0' || (str[0] == '-' && str[1] == '\0')) { /* Empty or "-": return 0 */
        *result = new_t81bigint(0);
        if (!*result) return TRIT_MEM_FAIL;
        return TRIT_OK;
    }
    int sign = (str[0] == '-') ? 1 : 0; /* Detect sign */
    size_t start = (str[0] == '-') ? 1 : 0; /* Skip minus */
    size_t str_len = strlen(str);
    size_t num_digits = str_len - start; /* Number of digits */
    if (num_digits == 0) return TRIT_INVALID_INPUT; /* No digits */
    *result = (T81BigInt*)calloc(1, sizeof(T81BigInt));
    if (!*result) return TRIT_MEM_FAIL;
    if (allocate_digits(*result, num_digits) != TRIT_OK) {
        free(*result); *result = NULL; return TRIT_MEM_FAIL;
    }
    (*result)->sign = sign;
    size_t digit_idx = 0;
    for (size_t i = str_len - 1; i >= start; i--) { /* Parse right-to-left */
        int value = 0;
        if (i > start && str[i - 1] >= '0' && str[i - 1] <= '8') { /* Two-digit number */
            value = (str[i - 1] - '0') * 10 + (str[i] - '0');
            if (value > 80 || str[i - 1] == '0') { /* Invalid or leading zero */
                tritbig_free(*result); *result = NULL; return TRIT_INVALID_INPUT;
            }
            i--; /* Skip tens digit */
        } else { /* Single digit */
            value = str[i] - '0';
            if (value > 80) {
                tritbig_free(*result); *result = NULL; return TRIT_INVALID_INPUT;
            }
        }
        (*result)->digits[digit_idx++] = (unsigned char)value;
    }
    (*result)->len = digit_idx; /* Set actual length */
    while ((*result)->len > 1 && (*result)->digits[(*result)->len - 1] == 0) {
        (*result)->len--; /* Trim leading zeros */
    }
    if ((*result)->len == 1 && (*result)->digits[0] == 0) (*result)->sign = 0; /* Normalize zero */
    return TRIT_OK;
}

@* Function: t81bigint_to_trit_string.
Converts a T81BigInt to a base-81 string representation.
@c
TritError t81bigint_to_trit_string(T81BigInt *x, char **result) {
    if (!x || !result) return TRIT_INVALID_INPUT; /* Null check */
    size_t buf_size = x->len * 3 + 2; /* Max 2 chars per digit + sign + null */
    *result = (char*)malloc(buf_size);
    if (!*result) return TRIT_MEM_FAIL;
    size_t pos = 0;
    if (x->sign) (*result)[pos++] = '-'; /* Add sign if negative */
    if (x->len == 1 && x->digits[0] == 0) { /* Special case for zero */
        (*result)[pos++] = '0';
        (*result)[pos] = '\0';
        return TRIT_OK;
    }
    for (int i = x->len - 1; i >= 0; i--) { /* Most to least significant */
        pos += sprintf(*result + pos, "%d", x->digits[i]);
    }
    (*result)[pos] = '\0'; /* Null terminate */
    return TRIT_OK;
}

@* Function: tritjs_add_big.
Adds two nonnegative T81BigInts.
@c
TritError tritjs_add_big(T81BigInt *A, T81BigInt *B, T81BigInt **result) {
    size_t max_len = (A->len > B->len) ? A->len : B->len;
    *result = (T81BigInt*)calloc(1, sizeof(T81BigInt));
    if (!*result) return TRIT_MEM_FAIL;
    if (allocate_digits(*result, max_len + 1) != TRIT_OK) { free(*result); return TRIT_MEM_FAIL; }
    int carry = 0;
    for (size_t i = 0; i < max_len || carry; i++) { /* Digit-by-digit addition */
        if (i >= (*result)->len) allocate_digits(*result, i + 1); /* Extend if needed */
        int sum = carry + (i < A->len ? A->digits[i] : 0) + (i < B->len ? B->digits[i] : 0);
        (*result)->digits[i] = sum % BASE_81; /* Store digit */
        carry = sum / BASE_81; /* Carry to next digit */
        (*result)->len = i + 1;
    }
    return TRIT_OK;
}

@* Function: tritjs_subtract_big.
Subtracts B from A (assumes A >= B).
@c
TritError tritjs_subtract_big(T81BigInt *A, T81BigInt *B, T81BigInt **result) {
    if (t81bigint_compare(A, B) < 0) return TRIT_INVALID_INPUT; /* A < B not supported */
    *result = (T81BigInt*)calloc(1, sizeof(T81BigInt));
    if (!*result) return TRIT_MEM_FAIL;
    if (allocate_digits(*result, A->len) != TRIT_OK) { free(*result); return TRIT_MEM_FAIL; }
    int borrow = 0;
    for (size_t i = 0; i < A->len; i++) { /* Digit-by-digit subtraction */
        int diff = A->digits[i] - (i < B->len ? B->digits[i] : 0) - borrow;
        if (diff < 0) { diff += BASE_81; borrow = 1; } else borrow = 0;
        (*result)->digits[i] = diff;
        (*result)->len = i + 1;
    }
    while ((*result)->len > 1 && (*result)->digits[(*result)->len - 1] == 0) (*result)->len--; /* Trim zeros */
    return TRIT_OK;
}

@* Function: tritjs_multiply_big.
Multiplies two nonnegative T81BigInts using schoolbook multiplication.
@c
TritError tritjs_multiply_big(T81BigInt *A, T81BigInt *B, T81BigInt **result) {
    *result = (T81BigInt*)calloc(1, sizeof(T81BigInt));
    if (!*result) return TRIT_MEM_FAIL;
    if (allocate_digits(*result, A->len + B->len) != TRIT_OK) { free(*result); return TRIT_MEM_FAIL; }
    for (size_t i = 0; i < A->len; i++) { /* Multiply each digit of A */
        int carry = 0;
        for (size_t j = 0; j < B->len || carry; j++) { /* By each digit of B */
            size_t k = i + j;
            if (k >= (*result)->len) allocate_digits(*result, k + 1);
            int prod = (*result)->digits[k] + A->digits[i] * (j < B->len ? B->digits[j] : 0) + carry;
            (*result)->digits[k] = prod % BASE_81;
            carry = prod / BASE_81;
            if (k + 1 > (*result)->len) (*result)->len = k + 1;
        }
    }
    while ((*result)->len > 1 && (*result)->digits[(*result)->len - 1] == 0) (*result)->len--; /* Trim zeros */
    return TRIT_OK;
}

@*3 Recursive Division Algorithm for T81BigInt.
Optimized division using a hybrid doubling/subtraction method.
@c
TritError t81_recursive_divide_big(T81BigInt *A, T81BigInt *B, T81BigInt **quotient, T81BigInt **remainder) {
    if (t81bigint_compare(A, B) < 0) { /* Base case: A < B */
        *quotient = new_t81bigint(0);
        *remainder = copy_t81bigint(A);
        if (!*quotient || !*remainder) return TRIT_MEM_FAIL;
        return TRIT_OK;
    }
    T81BigInt *q = new_t81bigint(0), *temp = NULL; /* Initialize quotient */
    *remainder = copy_t81bigint(A); /* Copy A as initial remainder */
    if (!q || !*remainder) return TRIT_MEM_FAIL;
    while (t81bigint_compare(*remainder, B) >= 0) { /* Subtract largest multiple */
        T81BigInt *d = copy_t81bigint(B), *q_step = new_t81bigint(1);
        if (!d || !q_step) return TRIT_MEM_FAIL;
        while (t81bigint_compare(*remainder, d) >= 0) { /* Double until overshoot */
            if (tritjs_add_big(d, d, &temp) != TRIT_OK) return TRIT_MEM_FAIL;
            if (t81bigint_compare(temp, *remainder) > 0) { tritbig_free(temp); break; }
            tritbig_free(d); d = temp;
            if (tritjs_add_big(q_step, q_step, &temp) != TRIT_OK) return TRIT_MEM_FAIL;
            tritbig_free(q_step); q_step = temp;
        }
        if (tritjs_subtract_big(*remainder, d, &temp) != TRIT_OK) return TRIT_MEM_FAIL;
        tritbig_free(*remainder); *remainder = temp; /* Update remainder */
        if (tritjs_add_big(q, q_step, &temp) != TRIT_OK) return TRIT_MEM_FAIL;
        tritbig_free(q); q = temp; /* Update quotient */
        tritbig_free(d); tritbig_free(q_step);
    }
    *quotient = q;
    return TRIT_OK;
}

@*4 T81Fraction: Exact Ternary Rational Numbers.
T81Fraction represents rational numbers as numerator/denominator pairs of T81BigInts.
@d T81Fraction_struct
typedef struct {
    T81BigInt numerator;     /* Numerator as T81BigInt */
    T81BigInt denominator;   /* Denominator as T81BigInt (non-zero) */
} T81Fraction;

@* Function: t81fraction_free.
Frees the resources of a T81Fraction.
@c
void t81fraction_free(T81Fraction *x) {
    if (!x) return;
    t81bigint_free(&x->numerator); /* Free numerator */
    t81bigint_free(&x->denominator); /* Free denominator */
    memset(x, 0, sizeof(*x)); /* Clear struct */
}

@* Function: t81fraction_new.
Creates a new T81Fraction from two integer strings.
@c
TritError t81fraction_new(const char *num_str, const char *denom_str, T81Fraction **result) {
    *result = (T81Fraction*)calloc(1, sizeof(T81Fraction));
    if (!*result) return TRIT_MEM_FAIL;
    TritError err = parse_trit_string(num_str, (T81BigInt**)&(*result)->numerator);
    if (err != TRIT_OK) { free(*result); return err; }
    err = parse_trit_string(denom_str, (T81BigInt**)&(*result)->denominator);
    if (err != TRIT_OK) { t81bigint_free(&(*result)->numerator); free(*result); return err; }
    if ((*result)->denominator.len == 1 && (*result)->denominator.digits[0] == 0) {
        t81fraction_free(*result); free(*result); return TRIT_DIV_ZERO; /* Denominator zero */
    }
    return TRIT_OK;
}

@* Function: t81fraction_add.
Adds two T81Fractions: (a/b) + (c/d) = (ad + bc)/(bd).
@c
TritError t81fraction_add(T81Fraction *A, T81Fraction *B, T81Fraction **result) {
    *result = (T81Fraction*)calloc(1, sizeof(T81Fraction));
    if (!*result) return TRIT_MEM_FAIL;
    
    T81BigInt *ad = NULL, *bc = NULL, *numer = NULL, *denom = NULL;
    /* Compute ad */
    if (tritjs_multiply_big(&A->numerator, &B->denominator, &ad) != TRIT_OK) goto cleanup;
    /* Compute bc */
    if (tritjs_multiply_big(&B->numerator, &A->denominator, &bc) != TRIT_OK) goto cleanup;
    /* Compute ad + bc */
    if (tritjs_add_big(ad, bc, &numer) != TRIT_OK) goto cleanup;
    /* Compute bd */
    if (tritjs_multiply_big(&A->denominator, &B->denominator, &denom) != TRIT_OK) goto cleanup;
    
    (*result)->numerator = *numer;
    (*result)->denominator = *denom;
    free(numer); free(denom); /* Transfer ownership */
    tritbig_free(ad); tritbig_free(bc); /* Cleanup intermediates */
    return TRIT_OK;

cleanup:
    tritbig_free(ad); tritbig_free(bc); tritbig_free(numer); tritbig_free(denom);
    free(*result); *result = NULL;
    return TRIT_MEM_FAIL;
}

@* Function: t81fraction_subtract.
Subtracts two T81Fractions: (a/b) - (c/d) = (ad - bc)/(bd).
@c
TritError t81fraction_subtract(T81Fraction *A, T81Fraction *B, T81Fraction **result) {
    *result = (T81Fraction*)calloc(1, sizeof(T81Fraction));
    if (!*result) return TRIT_MEM_FAIL;
    
    T81BigInt *ad = NULL, *bc = NULL, *numer = NULL, *denom = NULL;
    if (tritjs_multiply_big(&A->numerator, &B->denominator, &ad) != TRIT_OK) goto cleanup;
    if (tritjs_multiply_big(&B->numerator, &A->denominator, &bc) != TRIT_OK) goto cleanup;
    if (tritjs_subtract_big(ad, bc, &numer) != TRIT_OK) goto cleanup;
    if (tritjs_multiply_big(&A->denominator, &B->denominator, &denom) != TRIT_OK) goto cleanup;
    
    (*result)->numerator = *numer;
    (*result)->denominator = *denom;
    free(numer); free(denom);
    tritbig_free(ad); tritbig_free(bc);
    return TRIT_OK;

cleanup:
    tritbig_free(ad); tritbig_free(bc); tritbig_free(numer); tritbig_free(denom);
    free(*result); *result = NULL;
    return TRIT_MEM_FAIL;
}

@* Function: t81fraction_multiply.
Multiplies two T81Fractions: (a/b) * (c/d) = (ac)/(bd).
@c
TritError t81fraction_multiply(T81Fraction *A, T81Fraction *B, T81Fraction **result) {
    *result = (T81Fraction*)calloc(1, sizeof(T81Fraction));
    if (!*result) return TRIT_MEM_FAIL;
    
    T81BigInt *numer = NULL, *denom = NULL;
    if (tritjs_multiply_big(&A->numerator, &B->numerator, &numer) != TRIT_OK) goto cleanup;
    if (tritjs_multiply_big(&A->denominator, &B->denominator, &denom) != TRIT_OK) goto cleanup;
    
    (*result)->numerator = *numer;
    (*result)->denominator = *denom;
    free(numer); free(denom);
    return TRIT_OK;

cleanup:
    tritbig_free(numer); tritbig_free(denom);
    free(*result); *result = NULL;
    return TRIT_MEM_FAIL;
}

@* Function: t81fraction_divide.
Divides two T81Fractions: (a/b) / (c/d) = (ad)/(bc).
@c
TritError t81fraction_divide(T81Fraction *A, T81Fraction *B, T81Fraction **result) {
    if (B->numerator.len == 1 && B->numerator.digits[0] == 0) return TRIT_DIV_ZERO; /* Check divisor */
    *result = (T81Fraction*)calloc(1, sizeof(T81Fraction));
    if (!*result) return TRIT_MEM_FAIL;
    
    T81BigInt *numer = NULL, *denom = NULL;
    if (tritjs_multiply_big(&A->numerator, &B->denominator, &numer) != TRIT_OK) goto cleanup;
    if (tritjs_multiply_big(&A->denominator, &B->numerator, &denom) != TRIT_OK) goto cleanup;
    
    (*result)->numerator = *numer;
    (*result)->denominator = *denom;
    free(numer); free(denom);
    return TRIT_OK;

cleanup:
    tritbig_free(numer); tritbig_free(denom);
    free(*result); *result = NULL;
    return TRIT_MEM_FAIL;
}

@*5 T81Float: Floating-Point Ternary Numbers.
T81Float represents floating-point numbers with a mantissa and base-81 exponent.
@d T81Float_struct
typedef struct {
    T81BigInt mantissa; /* Significant digits */
    int exponent;       /* Base-81 exponent */
    int sign;           /* 0 = positive, 1 = negative */
} T81Float;

@* Function: t81float_free.
Releases resources for a T81Float.
@c
void t81float_free(T81Float *x) {
    if (!x) return;
    t81bigint_free(&x->mantissa); /* Free mantissa */
    memset(x, 0, sizeof(*x)); /* Clear struct */
}

@* Function: t81float_new.
Creates a T81Float from a mantissa string and exponent.
@c
TritError t81float_new(const char *mantissa_str, int exponent, T81Float **result) {
    *result = (T81Float*)calloc(1, sizeof(T81Float));
    if (!*result) return TRIT_MEM_FAIL;
    TritError err = parse_trit_string(mantissa_str, (T81BigInt**)&(*result)->mantissa);
    if (err != TRIT_OK) { free(*result); return err; }
    (*result)->exponent = exponent;
    (*result)->sign = (mantissa_str[0] == '-') ? 1 : 0;
    return t81float_normalize(*result); /* Normalize immediately */
}

@* Function: t81float_normalize.
Removes leading/trailing zeros from the mantissa and adjusts the exponent.
@c
TritError t81float_normalize(T81Float* f) {
    if (f->mantissa.len == 1 && f->mantissa.digits[0] == 0) { /* Zero case */
        f->exponent = 0;
        f->sign = 0;
        return TRIT_OK;
    }
    while (f->mantissa.len > 1 && f->mantissa.digits[f->mantissa.len - 1] == 0) {
        f->mantissa.len--; /* Remove trailing zeros */
        f->exponent++; /* Adjust exponent */
    }
    int leading_zeros = 0;
    for (size_t i = 0; i < f->mantissa.len; i++) {
        if (f->mantissa.digits[i] != 0) break;
        leading_zeros++;
    }
    if (leading_zeros > 0) { /* Remove leading zeros */
        memmove(f->mantissa.digits, f->mantissa.digits + leading_zeros, f->mantissa.len - leading_zeros);
        f->mantissa.len -= leading_zeros;
        f->exponent -= leading_zeros;
    }
    return TRIT_OK;
}

@* Function: t81float_multiply.
Multiplies two T81Float numbers.
@c
TritError t81float_multiply(T81Float* A, T81Float* B, T81Float** result) {
    *result = (T81Float*)calloc(1, sizeof(T81Float));
    if (!*result) return TRIT_MEM_FAIL;
    T81BigInt *product = NULL;
    TritError err = tritjs_multiply_big(&A->mantissa, &B->mantissa, &product);
    if (err != TRIT_OK) { free(*result); return err; }
    (*result)->mantissa = *product;
    (*result)->exponent = A->exponent + B->exponent; /* Add exponents */
    (*result)->sign = (A->sign != B->sign) ? 1 : 0; /* XOR signs */
    err = t81float_normalize(*result);
    if (err != TRIT_OK) { t81float_free(*result); free(*result); return err; }
    free(product); /* Free intermediate */
    return TRIT_OK;
}

@* Function: t81float_divide.
Divides two T81Float numbers using recursive division for mantissas.
@c
TritError t81float_divide(T81Float* A, T81Float* B, T81Float** result) {
    if (B->mantissa.len == 1 && B->mantissa.digits[0] == 0) return TRIT_DIV_ZERO; /* Check divisor */
    *result = (T81Float*)calloc(1, sizeof(T81Float));
    if (!*result) return TRIT_MEM_FAIL;
    T81BigInt *quotient = NULL, *remainder = NULL;
    TritError err = t81_recursive_divide_big(&A->mantissa, &B->mantissa, &quotient, &remainder);
    if (err != TRIT_OK) { free(*result); return err; }
    (*result)->mantissa = *quotient;
    (*result)->exponent = A->exponent - B->exponent; /* Subtract exponents */
    (*result)->sign = (A->sign != B->sign) ? 1 : 0; /* XOR signs */
    err = t81float_normalize(*result);
    if (err != TRIT_OK) { t81float_free(*result); free(*result); return err; }
    tritbig_free(quotient); tritbig_free(remainder); /* Free intermediates */
    return TRIT_OK;
}

@*6 Tower of Hanoi Implementation.
A recursive solution to the Tower of Hanoi puzzle, demonstrating recursion.
@c
void hanoi(int n, char src, char dst, char aux) {
    if (n == 1) { /* Base case: move single disk */
        printf("Move disk 1 from %c to %c\n", src, dst);
        return;
    }
    hanoi(n - 1, src, aux, dst); /* Move n-1 disks to auxiliary */
    printf("Move disk %d from %c to %c\n", n, src, dst); /* Move nth disk */
    hanoi(n - 1, aux, dst, src); /* Move n-1 disks to destination */
}

@*7 Main Function: Testing the Implementation.
Tests all major components: T81BigInt, T81Fraction, T81Float, and Tower of Hanoi.
@c
int main(void) {
    /* Test T81BigInt addition and division */
    T81BigInt *A, *B, *sum, *quot, *rem;
    char *resultStr;
    if (parse_trit_string("102", &A) != TRIT_OK || parse_trit_string("21", &B) != TRIT_OK) {
        fprintf(stderr, "Error parsing T81BigInt inputs\n");
        return 1;
    }
    if (tritjs_add_big(A, B, &sum) != TRIT_OK) {
        fprintf(stderr, "Error adding T81BigInts\n");
        return 1;
    }
    if (t81bigint_to_trit_string(sum, &resultStr) != TRIT_OK) {
        fprintf(stderr, "Error converting sum to string\n");
        return 1;
    }
    printf("T81BigInt Sum (102 + 21): %s\n", resultStr);
    free(resultStr); tritbig_free(sum);
    
    if (t81_recursive_divide_big(A, B, &quot, &rem) != TRIT_OK) {
        fprintf(stderr, "Error in recursive division\n");
        return 1;
    }
    if (t81bigint_to_trit_string(quot, &resultStr) != TRIT_OK) {
        fprintf(stderr, "Error converting quotient\n");
        return 1;
    }
    printf("T81BigInt Division (102 / 21) Quotient: %s\n", resultStr);
    free(resultStr);
    if (t81bigint_to_trit_string(rem, &resultStr) != TRIT_OK) {
        fprintf(stderr, "Error converting remainder\n");
        return 1;
    }
    printf("Remainder: %s\n", resultStr);
    free(resultStr);
    tritbig_free(A); tritbig_free(B); tritbig_free(quot); tritbig_free(rem);

    /* Test T81Fraction addition */
    T81Fraction *F1, *F2, *Fsum;
    if (t81fraction_new("1", "2", &F1) != TRIT_OK || t81fraction_new("1", "3", &F2) != TRIT_OK) {
        fprintf(stderr, "Error creating fractions\n");
        return 1;
    }
    if (t81fraction_add(F1, F2, &Fsum) != TRIT_OK) {
        fprintf(stderr, "Error adding fractions\n");
        return 1;
    }
    if (t81bigint_to_trit_string(&Fsum->numerator, &resultStr) != TRIT_OK) return 1;
    printf("T81Fraction Sum (1/2 + 1/3) Numerator: %s\n", resultStr);
    free(resultStr);
    if (t81bigint_to_trit_string(&Fsum->denominator, &resultStr) != TRIT_OK) return 1;
    printf("Denominator: %s\n", resultStr);
    free(resultStr);
    t81fraction_free(F1); free(F1); t81fraction_free(F2); free(F2); t81fraction_free(Fsum); free(Fsum);

    /* Test T81Float multiplication and division */
    T81Float *F3, *F4, *Fprod, *Fquot;
    if (t81float_new("102", 0, &F3) != TRIT_OK || t81float_new("21", 0, &F4) != TRIT_OK) {
        fprintf(stderr, "Error creating floats\n");
        return 1;
    }
    if (t81float_multiply(F3, F4, &Fprod) != TRIT_OK) {
        fprintf(stderr, "Error multiplying floats\n");
        return 1;
    }
    if (t81bigint_to_trit_string(&Fprod->mantissa, &resultStr) != TRIT_OK) return 1;
    printf("T81Float Product (102 * 21) Mantissa: %s, Exponent: %d\n", resultStr, Fprod->exponent);
    free(resultStr);
    
    if (t81float_divide(F3, F4, &Fquot) != TRIT_OK) {
        fprintf(stderr, "Error dividing floats\n");
        return 1;
    }
    if (t81bigint_to_trit_string(&Fquot->mantissa, &resultStr) != TRIT_OK) return 1;
    printf("T81Float Quotient (102 / 21) Mantissa: %s, Exponent: %d\n", resultStr, Fquot->exponent);
    free(resultStr);
    t81float_free(F3); free(F3); t81float_free(F4); free(F4);
    t81float_free(Fprod); free(Fprod); t81float_free(Fquot); free(Fquot);

    /* Demonstrate Tower of Hanoi */
    printf("\nTower of Hanoi with 3 disks:\n");
    hanoi(3, 'A', 'C', 'B');

    return 0;
}
