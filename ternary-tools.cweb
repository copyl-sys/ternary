/*=====================================================================
  Ternary Tools Suite: Minimalist Ternary Computing Utilities in Rust
  Version: 1.1-RS
  Author: Grok (inspired by Copyleft Systems)
  Date: Mar 3 2025

  This literate program presents a suite of small, focused Rust tools for ternary
  computing, adhering to Linux's "do one thing well" philosophy. Each utility is
  designed for pipeline use, reading from stdin where practical, writing to stdout,
  and reporting errors to stderr. The suite refactors and extends Ternary Systems
  B02-RS, covering its core features plus new utilities:
    - ternary-calc: Evaluates ternary arithmetic expressions.
    - ternary-hanoi: Solves the Tower of Hanoi problem.
    - ternary-matrix: Performs matrix operations (add, multiply, serialize, deserialize).
    - ternary-opcode: Encodes or validates ternary opcodes.
    - ternary-convert: Converts between decimal and ternary numbers.
    - ternary-checksum: Computes or verifies ternary checksums.
  Built with Rust for safety and portability, these tools are lightweight, composable,
  and ideal for scripting (e.g., `echo "12+21" | ternary-calc`).
=====================================================================*/

/*=====================================================================
  Ternary Calculator: ternary-calc.rs
  Evaluates a ternary arithmetic expression from stdin, outputs to stdout in
  ternary (default) or decimal (--decimal flag). Supports +, -, *, /, and parentheses.
=====================================================================*/
@* Ternary Calculator: ternary-calc.rs
@o ternary-calc.rs
@c
use std::io::{self, BufRead, Write};
use std::env;
use std::process;

#[derive(Debug)]
enum ParseError {
    InvalidDigit(char),
    UnexpectedChar(char),
    MissingClosingParen,
    DivisionByZero,
    EmptyInput,
}

impl std::fmt::Display for ParseError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            ParseError::InvalidDigit(c) => write!(f, "invalid digit '{}': expected 0, 1, or 2", c),
            ParseError::UnexpectedChar(c) => write!(f, "unexpected character '{}'", c),
            ParseError::MissingClosingParen => write!(f, "missing closing parenthesis"),
            ParseError::DivisionByZero => write!(f, "division by zero"),
            ParseError::EmptyInput => write!(f, "empty input"),
        }
    }
}

fn evaluate_ternary(expr: &str) -> Result<i32, ParseError> {
    let expr = expr.trim();
    if expr.is_empty() { return Err(ParseError::EmptyInput); }
    let chars: Vec<char> = expr.chars().collect();
    let mut pos = 0;
    let result = parse_expr(&chars, &mut pos)?;
    while pos < chars.len() {
        if !chars[pos].is_whitespace() { return Err(ParseError::UnexpectedChar(chars[pos])); }
        pos += 1;
    }
    Ok(result)
}

fn parse_expr(chars: &[char], pos: &mut usize) -> Result<i32, ParseError> {
    let mut value = parse_term(chars, pos)?;
    while *pos < chars.len() {
        skip_whitespace(chars, pos);
        match chars.get(*pos) {
            Some('+') => { *pos += 1; value += parse_term(chars, pos)?; }
            Some('-') => { *pos += 1; value -= parse_term(chars, pos)?; }
            _ => break,
        }
    }
    Ok(value)
}

fn parse_term(chars: &[char], pos: &mut usize) -> Result<i32, ParseError> {
    let mut value = parse_factor(chars, pos)?;
    while *pos < chars.len() {
        skip_whitespace(chars, pos);
        match chars.get(*pos) {
            Some('*') => { *pos += 1; value *= parse_factor(chars, pos)?; }
            Some('/') => {
                *pos += 1;
                let next = parse_factor(chars, pos)?;
                if next == 0 { return Err(ParseError::DivisionByZero); }
                value /= next;
            }
            _ => break,
        }
    }
    Ok(value)
}

fn parse_factor(chars: &[char], pos: &mut usize) -> Result<i32, ParseError> {
    skip_whitespace(chars, pos);
    if *pos >= chars.len() { return Err(ParseError::UnexpectedChar('\0')); }
    if chars[*pos] == '(' {
        *pos += 1;
        let value = parse_expr(chars, pos)?;
        skip_whitespace(chars, pos);
        if *pos >= chars.len() || chars[*pos] != ')' { return Err(ParseError::MissingClosingParen); }
        *pos += 1;
        Ok(value)
    } else {
        parse_number(chars, pos)
    }
}

fn parse_number(chars: &[char], pos: &mut usize) -> Result<i32, ParseError> {
    skip_whitespace(chars, pos);
    if *pos >= chars.len() { return Err(ParseError::UnexpectedChar('\0')); }
    let mut value = 0;
    let mut has_digits = false;
    while *pos < chars.len() {
        let c = chars[*pos];
        if c >= '0' && c <= '2' {
            value = value * 3 + (c as i32 - '0' as i32);
            has_digits = true;
            *pos += 1;
        } else {
            break;
        }
    }
    if !has_digits { return Err(ParseError::InvalidDigit(chars[*pos])); }
    Ok(value)
}

fn skip_whitespace(chars: &[char], pos: &mut usize) {
    while *pos < chars.len() && chars[*pos].is_whitespace() { *pos += 1; }
}

fn int_to_ternary(n: i32) -> String {
    if n == 0 { return "0".to_string(); }
    let mut digits = Vec::new();
    let mut num = n.abs();
    while num > 0 {
        digits.push((num % 3) as u8 + b'0');
        num /= 3;
    }
    if n < 0 { digits.push(b'-'); }
    String::from_utf8(digits.into_iter().rev().collect()).unwrap()
}

fn main() {
    let args: Vec<String> = env::args().collect();
    let decimal_output = args.iter().any(|arg| arg == "--decimal");

    let mut input = String::new();
    io::stdin().lock().read_line(&mut input).unwrap_or_else(|e| {
        eprintln!("error: failed to read input: {}", e);
        process::exit(1);
    });

    match evaluate_ternary(&input) {
        Ok(result) => {
            let output = if decimal_output { result.to_string() } else { int_to_ternary(result) };
            writeln!(io::stdout(), "{}", output).unwrap_or_else(|e| {
                eprintln!("error: failed to write output: {}", e);
                process::exit(1);
            });
        }
        Err(e) => {
            eprintln!("error: {}", e);
            process::exit(1);
        }
    }
}
@*/

/*=====================================================================
  Ternary Hanoi Solver: ternary-hanoi.rs
  Solves Tower of Hanoi for a number of disks from stdin, printing moves to stdout.
=====================================================================*/
@* Ternary Hanoi Solver: ternary-hanoi.rs
@o ternary-hanoi.rs
@c
use std::io::{self, BufRead, Write};
use std::process;

fn solve_hanoi(n: i32) {
    let mut state: Vec<i32> = vec![0; n as usize];
    println!("Initial state (all disks on peg 0):");
    print_state(&state);
    solve_hanoi_recursive(n, 0, 2, 1, &mut state);
}

fn solve_hanoi_recursive(n: i32, from: i32, to: i32, aux: i32, state: &mut Vec<i32>) {
    if n == 0 { return; }
    solve_hanoi_recursive(n - 1, from, aux, to, state);
    hanoi_move(n - 1, from, to, state);
    solve_hanoi_recursive(n - 1, aux, to, from, state);
}

fn hanoi_move(disk: i32, from: i32, to: i32, state: &mut Vec<i32>) {
    println!("Move disk {} from peg {} to peg {}", disk, from, to);
    state[disk as usize] = to;
    print_state(state);
}

fn print_state(state: &[i32]) {
    print!("State: ");
    for &peg in state.iter().rev() { print!("{}", peg); }
    println!();
}

fn main() {
    let mut input = String::new();
    io::stdin().lock().read_line(&mut input).unwrap_or_else(|e| {
        eprintln!("error: failed to read input: {}", e);
        process::exit(1);
    });
    match input.trim().parse::<i32>() {
        Ok(n) if n >= 0 => solve_hanoi(n),
        Ok(_) => {
            eprintln!("error: number of disks must be non-negative");
            process::exit(1);
        }
        Err(_) => {
            eprintln!("error: invalid number of disks");
            process::exit(1);
        }
    }
}
@*/

/*=====================================================================
  Ternary Matrix Operations: ternary-matrix.rs
  Performs matrix operations with subcommands (add, mul, ser, des). Add and
  multiply now support stdin input, while ser/des use files.
=====================================================================*/
@* Ternary Matrix Operations: ternary-matrix.rs
@o ternary-matrix.rs
@c
use std::fs::File;
use std::io::{self, BufRead, BufReader, Write};
use std::env;
use std::process;

#[derive(Debug)]
struct TMatrix {
    rows: usize,
    cols: usize,
    data: Vec<Vec<i32>>,
}

impl TMatrix {
    fn new(rows: usize, cols: usize) -> TMatrix {
        let data = vec![vec![0; cols]; rows];
        TMatrix { rows, cols, data }
    }

    fn add(&self, other: &TMatrix) -> Result<TMatrix, String> {
        if self.rows != other.rows || self.cols != other.cols {
            return Err("matrix dimensions mismatch for addition".to_string());
        }
        let mut result = TMatrix::new(self.rows, self.cols);
        for i in 0..self.rows {
            for j in 0..self.cols {
                result.data[i][j] = self.data[i][j] + other.data[i][j];
            }
        }
        Ok(result)
    }

    fn multiply(&self, other: &TMatrix) -> Result<TMatrix, String> {
        if self.cols != other.rows {
            return Err("matrix dimensions mismatch for multiplication".to_string());
        }
        let mut result = TMatrix::new(self.rows, other.cols);
        for i in 0..self.rows {
            for j in 0..other.cols {
                let mut sum = 0;
                for k in 0..self.cols {
                    sum += self.data[i][k] * other.data[k][j];
                }
                result.data[i][j] = sum;
            }
        }
        Ok(result)
    }

    fn serialize(&self, filename: &str) -> io::Result<()> {
        let mut file = File::create(filename)?;
        writeln!(file, "{} {}", self.rows, self.cols)?;
        for i in 0..self.rows {
            for j in 0..self.cols {
                write!(file, "{} ", int_to_ternary(self.data[i][j]))?;
            }
            writeln!(file)?;
        }
        Ok(())
    }

    fn deserialize(filename: &str) -> io::Result<TMatrix> {
        let file = File::open(filename)?;
        let reader = BufReader::new(file);
        parse_matrix(reader)
    }

    fn from_stdin() -> io::Result<TMatrix> {
        let stdin = io::stdin();
        let reader = stdin.lock();
        parse_matrix(reader)
    }
}

fn int_to_ternary(n: i32) -> String {
    if n == 0 { return "0".to_string(); }
    let mut digits = Vec::new();
    let mut num = n.abs();
    while num > 0 {
        digits.push((num % 3) as u8 + b'0');
        num /= 3;
    }
    if n < 0 { digits.push(b'-'); }
    String::from_utf8(digits.into_iter().rev().collect()).unwrap()
}

fn parse_ternary(s: &str) -> io::Result<i32> {
    let mut value = 0;
    let mut is_negative = false;
    let chars: Vec<char> = s.chars().collect();
    let mut i = 0;
    if chars.is_empty() { return Err(io::Error::new(io::ErrorKind::InvalidData, "empty ternary string")); }
    if chars[0] == '-' { is_negative = true; i += 1; }
    while i < chars.len() {
        let c = chars[i];
        if c < '0' || c > '2' { return Err(io::Error::new(io::ErrorKind::InvalidData, format!("invalid ternary digit '{}'", c))); }
        value = value * 3 + (c as i32 - '0' as i32);
        i += 1;
    }
    Ok(if is_negative { -value } else { value })
}

fn parse_matrix<R: BufRead>(reader: R) -> io::Result<TMatrix> {
    let mut lines = reader.lines();
    let first_line = lines.next().ok_or_else(|| io::Error::new(io::ErrorKind::InvalidData, "empty input"))??;
    let dims: Vec<usize> = first_line.split_whitespace()
        .map(|s| s.parse().map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e)))
        .collect::<Result<_, _>>()?;
    if dims.len() != 2 { return Err(io::Error::new(io::ErrorKind::InvalidData, "invalid dimensions")); }
    let rows = dims[0];
    let cols = dims[1];
    let mut data = Vec::with_capacity(rows);
    for line in lines.take(rows) {
        let line = line?;
        let row: Vec<i32> = line.split_whitespace()
            .map(|s| parse_ternary(s).map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e)))
            .collect::<Result<_, _>>()?;
        if row.len() != cols { return Err(io::Error::new(io::ErrorKind::InvalidData, "row length mismatch")); }
        data.push(row);
    }
    if data.len() != rows { return Err(io::Error::new(io::ErrorKind::InvalidData, "insufficient rows")); }
    Ok(TMatrix { rows, cols, data })
}

fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() < 2 {
        eprintln!("error: missing operation (add, mul, ser, des)");
        process::exit(1);
    }

    match args[1].as_str() {
        "add" => {
            let m1 = if args.len() > 2 { TMatrix::deserialize(&args[2]) } else { TMatrix::from_stdin() }
                .unwrap_or_else(|e| { eprintln!("error: failed to read first matrix: {}", e); process::exit(1); });
            let m2 = if args.len() > 3 { TMatrix::deserialize(&args[3]) } else { TMatrix::from_stdin() }
                .unwrap_or_else(|e| { eprintln!("error: failed to read second matrix: {}", e); process::exit(1); });
            let result = m1.add(&m2).unwrap_or_else(|e| { eprintln!("error: {}", e); process::exit(1); });
            result.serialize("/dev/stdout").unwrap_or_else(|e| { eprintln!("error: failed to write result: {}", e); process::exit(1); });
        }
        "mul" => {
            let m1 = if args.len() > 2 { TMatrix::deserialize(&args[2]) } else { TMatrix::from_stdin() }
                .unwrap_or_else(|e| { eprintln!("error: failed to read first matrix: {}", e); process::exit(1); });
            let m2 = if args.len() > 3 { TMatrix::deserialize(&args[3]) } else { TMatrix::from_stdin() }
                .unwrap_or_else(|e| { eprintln!("error: failed to read second matrix: {}", e); process::exit(1); });
            let result = m1.multiply(&m2).unwrap_or_else(|e| { eprintln!("error: {}", e); process::exit(1); });
            result.serialize("/dev/stdout").unwrap_or_else(|e| { eprintln!("error: failed to write result: {}", e); process::exit(1); });
        }
        "ser" => {
            if args.len() != 3 {
                eprintln!("error: usage: ternary-matrix ser <output_file>");
                process::exit(1);
            }
            let matrix = TMatrix::from_stdin().unwrap_or_else(|e| {
                eprintln!("error: failed to read matrix: {}", e);
                process::exit(1);
            });
            matrix.serialize(&args[2]).unwrap_or_else(|e| {
                eprintln!("error: failed to write {}: {}", args[2], e);
                process::exit(1);
            });
        }
        "des" => {
            if args.len() != 3 {
                eprintln!("error: usage: ternary-matrix des <input_file>");
                process::exit(1);
            }
            let matrix = TMatrix::deserialize(&args[2]).unwrap_or_else(|e| {
                eprintln!("error: failed to read {}: {}", args[2], e);
                process::exit(1);
            });
            matrix.serialize("/dev/stdout").unwrap_or_else(|e| {
                eprintln!("error: failed to write output: {}", e);
                process::exit(1);
            });
        }
        _ => {
            eprintln!("error: unknown operation '{}'; use add, mul, ser, or des", args[1]);
            process::exit(1);
        }
    }
}
@*/

/*=====================================================================
  Ternary Opcode Tool: ternary-opcode.rs
  Encodes or validates a ternary opcode from stdin, with a checksum-only mode.
=====================================================================*/
@* Ternary Opcode Tool: ternary-opcode.rs
@o ternary-opcode.rs
@c
use std::io::{self, BufRead, Write};
use std::env;
use std::process;

fn int_to_ternary(n: i32) -> String {
    if n == 0 { return "0".to_string(); }
    let mut digits = Vec::new();
    let mut num = n.abs();
    while num > 0 {
        digits.push((num % 3) as u8 + b'0');
        num /= 3;
    }
    if n < 0 { digits.push(b'-'); }
    String::from_utf8(digits.into_iter().rev().collect()).unwrap()
}

fn discrete_opcode_encode(opcode: i32) -> String {
    let ternary = int_to_ternary(opcode);
    let checksum = ternary.chars()
        .filter(|&c| c >= '0' && c <= '2')
        .map(|c| (c as u32 - '0' as u32) as i32)
        .sum::<i32>() % 3;
    format!("{}{}", ternary, checksum)
}

fn discrete_opcode_validate(encoded: &str) -> bool {
    if encoded.len() < 2 { return false; }
    let (code, checksum) = encoded.split_at(encoded.len() - 1);
    let checksum_digit = checksum.chars().next().unwrap();
    if checksum_digit < '0' || checksum_digit > '2' { return false; }
    let computed_sum = code.chars()
        .filter(|&c| c >= '0' && c <= '2')
        .map(|c| (c as u32 - '0' as u32) as i32)
        .sum::<i32>() % 3;
    computed_sum == (checksum_digit as u32 - '0' as u32) as i32
}

fn compute_checksum(s: &str) -> i32 {
    s.chars().filter(|&c| c >= '0' && c <= '2')
        .map(|c| (c as u32 - '0' as u32) as i32)
        .sum::<i32>() % 3
}

fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() < 2 {
        eprintln!("error: missing operation (encode, validate, checksum)");
        process::exit(1);
    }

    let mut input = String::new();
    io::stdin().lock().read_line(&mut input).unwrap_or_else(|e| {
        eprintln!("error: failed to read input: {}", e);
        process::exit(1);
    });
    let input = input.trim();

    match args[1].as_str() {
        "encode" => {
            let opcode = input.parse::<i32>().unwrap_or_else(|_| {
                eprintln!("error: invalid integer input");
                process::exit(1);
            });
            writeln!(io::stdout(), "{}", discrete_opcode_encode(opcode)).unwrap_or_else(|e| {
                eprintln!("error: failed to write output: {}", e);
                process::exit(1);
            });
        }
        "validate" => {
            let valid = discrete_opcode_validate(input);
            writeln!(io::stdout(), "{}", if valid { "valid" } else { "invalid" }).unwrap_or_else(|e| {
                eprintln!("error: failed to write output: {}", e);
                process::exit(1);
            });
        }
        "checksum" => {
            writeln!(io::stdout(), "{}", compute_checksum(input)).unwrap_or_else(|e| {
                eprintln!("error: failed to write output: {}", e);
                process::exit(1);
            });
        }
        _ => {
            eprintln!("error: unknown operation '{}'; use encode, validate, or checksum", args[1]);
            process::exit(1);
        }
    }
}
@*/

/*=====================================================================
  Ternary Converter: ternary-convert.rs
  Converts between decimal and ternary numbers from stdin, with direction via flag.
=====================================================================*/
@* Ternary Converter: ternary-convert.rs
@o ternary-convert.rs
@c
use std::io::{self, BufRead, Write};
use std::env;
use std::process;

fn int_to_ternary(n: i32) -> String {
    if n == 0 { return "0".to_string(); }
    let mut digits = Vec::new();
    let mut num = n.abs();
    while num > 0 {
        digits.push((num % 3) as u8 + b'0');
        num /= 3;
    }
    if n < 0 { digits.push(b'-'); }
    String::from_utf8(digits.into_iter().rev().collect()).unwrap()
}

fn parse_ternary(s: &str) -> Result<i32, String> {
    let mut value = 0;
    let mut is_negative = false;
    let chars: Vec<char> = s.chars().collect();
    let mut i = 0;
    if chars.is_empty() { return Err("empty input".to_string()); }
    if chars[0] == '-' { is_negative = true; i += 1; }
    while i < chars.len() {
        let c = chars[i];
        if c < '0' || c > '2' { return Err(format!("invalid ternary digit '{}'", c)); }
        value = value * 3 + (c as i32 - '0' as i32);
        i += 1;
    }
    Ok(if is_negative { -value } else { value })
}

fn main() {
    let args: Vec<String> = env::args().collect();
    let to_decimal = args.iter().any(|arg| arg == "--to-decimal");

    let mut input = String::new();
    io::stdin().lock().read_line(&mut input).unwrap_or_else(|e| {
        eprintln!("error: failed to read input: {}", e);
        process::exit(1);
    });
    let input = input.trim();

    let output = if to_decimal {
        parse_ternary(input).unwrap_or_else(|e| {
            eprintln!("error: {}", e);
            process::exit(1);
        }).to_string()
    } else {
        input.parse::<i32>().unwrap_or_else(|_| {
            eprintln!("error: invalid integer input");
            process::exit(1);
        });
        int_to_ternary(input.parse::<i32>().unwrap())
    };

    writeln!(io::stdout(), "{}", output).unwrap_or_else(|e| {
        eprintln!("error: failed to write output: {}", e);
        process::exit(1);
    });
}
@*/

/*=====================================================================
  Ternary Checksum Tool: ternary-checksum.rs
  Computes or verifies a ternary checksum from stdin based on mode.
=====================================================================*/
@* Ternary Checksum Tool: ternary-checksum.rs
@o ternary-checksum.rs
@c
use std::io::{self, BufRead, Write};
use std::env;
use std::process;

fn compute_checksum(s: &str) -> i32 {
    s.chars().filter(|&c| c >= '0' && c <= '2')
        .map(|c| (c as u32 - '0' as u32) as i32)
        .sum::<i32>() % 3
}

fn main() {
    let args: Vec<String> = env::args().collect();
    let mode = args.get(1).map(|s| s.as_str()).unwrap_or("compute");

    let mut input = String::new();
    io::stdin().lock().read_line(&mut input).unwrap_or_else(|e| {
        eprintln!("error: failed to read input: {}", e);
        process::exit(1);
    });
    let input = input.trim();

    match mode {
        "compute" => {
            writeln!(io::stdout(), "{}", compute_checksum(input)).unwrap_or_else(|e| {
                eprintln!("error: failed to write output: {}", e);
                process::exit(1);
            });
        }
        "verify" => {
            if input.len() < 2 {
                eprintln!("error: input too short for verification");
                process::exit(1);
            }
            let (code, check) = input.split_at(input.len() - 1);
            let valid = compute_checksum(code) == check.parse::<i32>().unwrap_or(-1);
            writeln!(io::stdout(), "{}", if valid { "valid" } else { "invalid" }).unwrap_or_else(|e| {
                eprintln!("error: failed to write output: {}", e);
                process::exit(1);
            });
        }
        _ => {
            eprintln!("error: unknown mode '{}'; use compute or verify", mode);
            process::exit(1);
        }
    }
}
@*/

/*=====================================================================
  End of Ternary Tools Suite CWEB Document
=====================================================================*/
