/*=====================================================================
  Ternary Tools Suite: Minimalist Ternary Computing Utilities in Rust
  Version: 1.2-RS (with Interoperability Enhancements)
  Author: Grok (inspired by Copyleft Systems)
  Date: Mar 3 2025
=====================================================================*/

use std::env;
use std::io::{self, BufRead, Write};
use std::process;

/// Prints unified help documentation for all subcommands.
fn print_help() {
    println!("Ternary Tools Suite (Rust Version) - Interoperability Enhanced");
    println!("Usage:");
    println!("  ternary-tools <subcommand> [options]");
    println!();
    println!("Subcommands:");
    println!("  calc       Evaluate ternary arithmetic expressions");
    println!("  hanoi      Solve Tower of Hanoi");
    println!("  matrix     Perform matrix operations");
    println!("  opcode     Encode or validate opcodes");
    println!("  convert    Convert between decimal and ternary");
    println!("  checksum   Compute or verify ternary checksums");
    println!();
    println!("Common Options:");
    println!("  --input <file>          Read input from a file (default: stdin)");
    println!("  --output-format <fmt>   Output format: plain (default) or json");
    println!("  --verbose               Enable verbose logging to stderr");
    println!("  --help                  Display this help message");
}

/// Runs the 'calc' subcommand, evaluating a ternary arithmetic expression.
/// Supports reading from stdin or from a file and outputs in plain text or JSON.
fn run_calc(args: &[String]) {
    let mut input_expr = String::new();
    let mut output_format = "plain"; // default output format
    let mut verbose = false;

    // Parse options
    let mut i = 0;
    while i < args.len() {
        match args[i].as_str() {
            "--input" => {
                i += 1;
                if i < args.len() {
                    match std::fs::read_to_string(&args[i]) {
                        Ok(contents) => input_expr = contents.trim().to_string(),
                        Err(e) => {
                            eprintln!("Error reading input file '{}': {}", args[i], e);
                            process::exit(1);
                        }
                    }
                } else {
                    eprintln!("--input flag requires a filename");
                    process::exit(1);
                }
            }
            "--output-format" => {
                i += 1;
                if i < args.len() {
                    output_format = &args[i];
                    if output_format != "plain" && output_format != "json" {
                        eprintln!("Unsupported output format '{}'. Use 'plain' or 'json'.", output_format);
                        process::exit(1);
                    }
                } else {
                    eprintln!("--output-format flag requires an argument (plain/json)");
                    process::exit(1);
                }
            }
            "--verbose" => {
                verbose = true;
            }
            _ => {
                // Assume first non-option argument is the expression.
                if input_expr.is_empty() {
                    input_expr = args[i].clone();
                }
            }
        }
        i += 1;
    }

    // If no expression provided, read from stdin.
    if input_expr.is_empty() {
        if verbose {
            eprintln!("No expression provided. Reading from stdin...");
        }
        let stdin = io::stdin();
        let mut lines = stdin.lock().lines();
        if let Some(Ok(line)) = lines.next() {
            input_expr = line;
        } else {
            eprintln!("Failed to read from stdin.");
            process::exit(1);
        }
    }

    // Evaluate the expression using the existing evaluator.
    match tritjs_eval_expression(&input_expr) {
        Ok(result) => {
            let ternary_result = int_to_ternary(result);
            if output_format == "json" {
                println!("{{ \"result\": \"{}\", \"value\": {} }}", ternary_result, result);
            } else {
                println!("Expression evaluated to (ternary): {}", ternary_result);
            }
        }
        Err(e) => {
            eprintln!("Error evaluating expression: {}", e);
            process::exit(1);
        }
    }
}

// Stub functions for other subcommands to be implemented similarly.
fn run_hanoi(_args: &[String]) {
    eprintln!("hanoi functionality not yet integrated in this demo.");
}

fn run_matrix(_args: &[String]) {
    eprintln!("matrix functionality not yet integrated in this demo.");
}

fn run_opcode(_args: &[String]) {
    eprintln!("opcode functionality not yet integrated in this demo.");
}

fn run_convert(_args: &[String]) {
    eprintln!("convert functionality not yet integrated in this demo.");
}

fn run_checksum(_args: &[String]) {
    eprintln!("checksum functionality not yet integrated in this demo.");
}

/// The main entry point dispatches subcommands based on the CLI.
fn main() {
    let args: Vec<String> = env::args().collect();

    // Display help if no subcommand is provided or help flag is present.
    if args.len() < 2 || args.iter().any(|arg| arg == "--help" || arg == "-h") {
        print_help();
        return;
    }

    let subcommand = &args[1];
    let sub_args = &args[2..];

    match subcommand.as_str() {
        "calc" => run_calc(sub_args),
        "hanoi" => run_hanoi(sub_args),
        "matrix" => run_matrix(sub_args),
        "opcode" => run_opcode(sub_args),
        "convert" => run_convert(sub_args),
        "checksum" => run_checksum(sub_args),
        _ => {
            eprintln!("Unknown subcommand: '{}'", subcommand);
            print_help();
            process::exit(1);
        }
    }
}

/*=====================================================================
  Below are the existing functions from the original ternary-tools library.
  These include the ternary expression evaluator and helper routines.
=====================================================================*/

#[derive(Debug)]
enum ParseError {
    InvalidDigit(char),
    UnexpectedChar(char),
    MissingClosingParen,
    DivisionByZero,
    EmptyExpression,
}

impl std::fmt::Display for ParseError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            ParseError::InvalidDigit(c) => write!(f, "Invalid digit '{}': expected 0, 1, or 2", c),
            ParseError::UnexpectedChar(c) => write!(f, "Unexpected character '{}'", c),
            ParseError::MissingClosingParen => write!(f, "Missing closing parenthesis"),
            ParseError::DivisionByZero => write!(f, "Division by zero"),
            ParseError::EmptyExpression => write!(f, "Expression is empty"),
        }
    }
}

/// Evaluates a ternary arithmetic expression provided as a string.
fn tritjs_eval_expression(expr: &str) -> Result<i32, ParseError> {
    let expr = expr.trim();
    if expr.is_empty() {
        return Err(ParseError::EmptyExpression);
    }
    let chars: Vec<char> = expr.chars().collect();
    let mut pos = 0;
    let result = parse_expr(&chars, &mut pos)?;
    while pos < chars.len() {
        if !chars[pos].is_whitespace() {
            return Err(ParseError::UnexpectedChar(chars[pos]));
        }
        pos += 1;
    }
    Ok(result)
}

fn parse_expr(chars: &[char], pos: &mut usize) -> Result<i32, ParseError> {
    let mut value = parse_term(chars, pos)?;
    while *pos < chars.len() {
        skip_whitespace(chars, pos);
        match chars.get(*pos) {
            Some('+') => {
                *pos += 1;
                value += parse_term(chars, pos)?;
            }
            Some('-') => {
                *pos += 1;
                value -= parse_term(chars, pos)?;
            }
            _ => break,
        }
    }
    Ok(value)
}

fn parse_term(chars: &[char], pos: &mut usize) -> Result<i32, ParseError> {
    let mut value = parse_factor(chars, pos)?;
    while *pos < chars.len() {
        skip_whitespace(chars, pos);
        match chars.get(*pos) {
            Some('*') => {
                *pos += 1;
                value *= parse_factor(chars, pos)?;
            }
            Some('/') => {
                *pos += 1;
                let next = parse_factor(chars, pos)?;
                if next == 0 {
                    return Err(ParseError::DivisionByZero);
                }
                value /= next;
            }
            _ => break,
        }
    }
    Ok(value)
}

fn parse_factor(chars: &[char], pos: &mut usize) -> Result<i32, ParseError> {
    skip_whitespace(chars, pos);
    if *pos >= chars.len() {
        return Err(ParseError::UnexpectedChar('\0'));
    }
    if chars[*pos] == '(' {
        *pos += 1;
        let value = parse_expr(chars, pos)?;
        skip_whitespace(chars, pos);
        if *pos >= chars.len() || chars[*pos] != ')' {
            return Err(ParseError::MissingClosingParen);
        }
        *pos += 1;
        Ok(value)
    } else {
        parse_number(chars, pos)
    }
}

fn parse_number(chars: &[char], pos: &mut usize) -> Result<i32, ParseError> {
    skip_whitespace(chars, pos);
    if *pos >= chars.len() {
        return Err(ParseError::UnexpectedChar('\0'));
    }
    let mut value = 0;
    let mut has_digits = false;
    while *pos < chars.len() {
        let c = chars[*pos];
        if c >= '0' && c <= '2' {
            value = value * 3 + (c as i32 - '0' as i32);
            has_digits = true;
            *pos += 1;
        } else {
            break;
        }
    }
    if !has_digits {
        return Err(ParseError::InvalidDigit(chars[*pos]));
    }
    Ok(value)
}

fn skip_whitespace(chars: &[char], pos: &mut usize) {
    while *pos < chars.len() && chars[*pos].is_whitespace() {
        *pos += 1;
    }
}

/// Converts an integer to its ternary (base 3) string representation.
fn int_to_ternary(n: i32) -> String {
    if n == 0 {
        return "0".to_string();
    }
    let mut digits = Vec::new();
    let mut num = n.abs();
    while num > 0 {
        digits.push((num % 3) as u8 + b'0');
        num /= 3;
    }
    if n < 0 {
        digits.push(b'-');
    }
    String::from_utf8(digits.into_iter().rev().collect()).unwrap()
}
