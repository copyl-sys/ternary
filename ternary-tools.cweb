/*=====================================================================
  Ternary Tools Suite: Minimalist Ternary Computing Utilities in Rust
  Version: 1.0-RS
  Author: Grok (inspired by Copyleft Systems)
  Date: Mar 3 2025

  This literate program reimagines Ternary Systems B02-RS as a suite of small,
  focused Rust tools, each designed to do one thing well in the Linux tradition.
  The suite includes:
    - ternary-calc: Evaluates ternary arithmetic expressions from stdin.
    - ternary-hanoi: Solves the Tower of Hanoi problem for a given number of disks.
    - ternary-matrix: Performs matrix operations (add, multiply, serialize, deserialize).
    - ternary-opcode: Encodes or validates ternary opcodes with a checksum.
  Each tool is standalone, reads from stdin where practical, writes to stdout,
  and reports errors to stderr, enabling pipeline composition (e.g.,
  `echo "12+21" | ternary-calc`). Built with Rust for safety and portability,
  these utilities are lightweight and script-friendly.
=====================================================================*/

/*=====================================================================
  Ternary Calculator: ternary-calc.rs
  Evaluates a single ternary arithmetic expression from stdin, outputs the
  result in ternary format to stdout. Supports +, -, *, /, and parentheses.
=====================================================================*/
@* Ternary Calculator: ternary-calc.rs
@o ternary-calc.rs
@c
use std::io::{self, BufRead, Write};
use std::process;

// Error enum for parsing ternary expressions.
#[derive(Debug)]
enum ParseError {
    InvalidDigit(char),     // Non-ternary digit encountered.
    UnexpectedChar(char),   // Invalid syntax character.
    MissingClosingParen,    // Unmatched opening parenthesis.
    DivisionByZero,         // Division by zero attempted.
    EmptyInput,             // No input provided.
}

impl std::fmt::Display for ParseError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            ParseError::InvalidDigit(c) => write!(f, "invalid digit '{}': expected 0, 1, or 2", c),
            ParseError::UnexpectedChar(c) => write!(f, "unexpected character '{}'", c),
            ParseError::MissingClosingParen => write!(f, "missing closing parenthesis"),
            ParseError::DivisionByZero => write!(f, "division by zero"),
            ParseError::EmptyInput => write!(f, "empty input"),
        }
    }
}

/// Evaluates a ternary expression from a string, returning the result or an error.
fn evaluate_ternary(expr: &str) -> Result<i32, ParseError> {
    let expr = expr.trim();
    if expr.is_empty() { return Err(ParseError::EmptyInput); }
    let chars: Vec<char> = expr.chars().collect();
    let mut pos = 0;
    let result = parse_expr(&chars, &mut pos)?;
    while pos < chars.len() {
        if !chars[pos].is_whitespace() { return Err(ParseError::UnexpectedChar(chars[pos])); }
        pos += 1;
    }
    Ok(result)
}

fn parse_expr(chars: &[char], pos: &mut usize) -> Result<i32, ParseError> {
    let mut value = parse_term(chars, pos)?;
    while *pos < chars.len() {
        skip_whitespace(chars, pos);
        match chars.get(*pos) {
            Some('+') => { *pos += 1; value += parse_term(chars, pos)?; }
            Some('-') => { *pos += 1; value -= parse_term(chars, pos)?; }
            _ => break,
        }
    }
    Ok(value)
}

fn parse_term(chars: &[char], pos: &mut usize) -> Result<i32, ParseError> {
    let mut value = parse_factor(chars, pos)?;
    while *pos < chars.len() {
        skip_whitespace(chars, pos);
        match chars.get(*pos) {
            Some('*') => { *pos += 1; value *= parse_factor(chars, pos)?; }
            Some('/') => {
                *pos += 1;
                let next = parse_factor(chars, pos)?;
                if next == 0 { return Err(ParseError::DivisionByZero); }
                value /= next;
            }
            _ => break,
        }
    }
    Ok(value)
}

fn parse_factor(chars: &[char], pos: &mut usize) -> Result<i32, ParseError> {
    skip_whitespace(chars, pos);
    if *pos >= chars.len() { return Err(ParseError::UnexpectedChar('\0')); }
    if chars[*pos] == '(' {
        *pos += 1;
        let value = parse_expr(chars, pos)?;
        skip_whitespace(chars, pos);
        if *pos >= chars.len() || chars[*pos] != ')' { return Err(ParseError::MissingClosingParen); }
        *pos += 1;
        Ok(value)
    } else {
        parse_number(chars, pos)
    }
}

fn parse_number(chars: &[char], pos: &mut usize) -> Result<i32, ParseError> {
    skip_whitespace(chars, pos);
    if *pos >= chars.len() { return Err(ParseError::UnexpectedChar('\0')); }
    let mut value = 0;
    let mut has_digits = false;
    while *pos < chars.len() {
        let c = chars[*pos];
        if c >= '0' && c <= '2' {
            value = value * 3 + (c as i32 - '0' as i32);
            has_digits = true;
            *pos += 1;
        } else {
            break;
        }
    }
    if !has_digits { return Err(ParseError::InvalidDigit(chars[*pos])); }
    Ok(value)
}

fn skip_whitespace(chars: &[char], pos: &mut usize) {
    while *pos < chars.len() && chars[*pos].is_whitespace() { *pos += 1; }
}

/// Converts an integer to ternary string representation.
fn int_to_ternary(n: i32) -> String {
    if n == 0 { return "0".to_string(); }
    let mut digits = Vec::new();
    let mut num = n.abs();
    while num > 0 {
        digits.push((num % 3) as u8 + b'0');
        num /= 3;
    }
    if n < 0 { digits.push(b'-'); }
    String::from_utf8(digits.into_iter().rev().collect()).unwrap()
}

fn main() {
    let stdin = io::stdin();
    let mut input = String::new();
    if let Err(e) = stdin.lock().read_line(&mut input) {
        eprintln!("error: failed to read input: {}", e);
        process::exit(1);
    }
    match evaluate_ternary(&input) {
        Ok(result) => {
            if let Err(e) = writeln!(io::stdout(), "{}", int_to_ternary(result)) {
                eprintln!("error: failed to write output: {}", e);
                process::exit(1);
            }
        }
        Err(e) => {
            eprintln!("error: {}", e);
            process::exit(1);
        }
    }
}
@*/

/*=====================================================================
  Ternary Hanoi Solver: ternary-hanoi.rs
  Solves the Tower of Hanoi for a number of disks provided via stdin,
  printing moves to stdout. Takes a single integer input.
=====================================================================*/
@* Ternary Hanoi Solver: ternary-hanoi.rs
@o ternary-hanoi.rs
@c
use std::io::{self, BufRead, Write};
use std::process;

fn solve_hanoi(n: i32) {
    let mut state: Vec<i32> = vec![0; n as usize];
    println!("Initial state (all disks on peg 0):");
    print_state(&state);
    solve_hanoi_recursive(n, 0, 2, 1, &mut state);
}

fn solve_hanoi_recursive(n: i32, from: i32, to: i32, aux: i32, state: &mut Vec<i32>) {
    if n == 0 { return; }
    solve_hanoi_recursive(n - 1, from, aux, to, state);
    hanoi_move(n - 1, from, to, state);
    solve_hanoi_recursive(n - 1, aux, to, from, state);
}

fn hanoi_move(disk: i32, from: i32, to: i32, state: &mut Vec<i32>) {
    println!("Move disk {} from peg {} to peg {}", disk, from, to);
    state[disk as usize] = to;
    print_state(state);
}

fn print_state(state: &[i32]) {
    print!("State: ");
    for &peg in state.iter().rev() { print!("{}", peg); }
    println!();
}

fn main() {
    let stdin = io::stdin();
    let mut input = String::new();
    if let Err(e) = stdin.lock().read_line(&mut input) {
        eprintln!("error: failed to read input: {}", e);
        process::exit(1);
    }
    match input.trim().parse::<i32>() {
        Ok(n) if n >= 0 => solve_hanoi(n),
        Ok(_) => {
            eprintln!("error: number of disks must be non-negative");
            process::exit(1);
        }
        Err(_) => {
            eprintln!("error: invalid number of disks");
            process::exit(1);
        }
    }
}
@*/

/*=====================================================================
  Ternary Matrix Operations: ternary-matrix.rs
  Performs matrix operations based on a command and input from stdin.
  Supports add, multiply, serialize, deserialize via flags and file-based I/O.
=====================================================================*/
@* Ternary Matrix Operations: ternary-matrix.rs
@o ternary-matrix.rs
@c
use std::fs::File;
use std::io::{self, BufRead, BufReader, Write};
use std::env;
use std::process;

#[derive(Debug)]
struct TMatrix {
    rows: usize,
    cols: usize,
    data: Vec<Vec<i32>>,
}

impl TMatrix {
    fn new(rows: usize, cols: usize) -> TMatrix {
        let data = vec![vec![0; cols]; rows];
        TMatrix { rows, cols, data }
    }

    fn add(&self, other: &TMatrix) -> Result<TMatrix, String> {
        if self.rows != other.rows || self.cols != other.cols {
            return Err("matrix dimensions mismatch for addition".to_string());
        }
        let mut result = TMatrix::new(self.rows, self.cols);
        for i in 0..self.rows {
            for j in 0..self.cols {
                result.data[i][j] = self.data[i][j] + other.data[i][j];
            }
        }
        Ok(result)
    }

    fn multiply(&self, other: &TMatrix) -> Result<TMatrix, String> {
        if self.cols != other.rows {
            return Err("matrix dimensions mismatch for multiplication".to_string());
        }
        let mut result = TMatrix::new(self.rows, other.cols);
        for i in 0..self.rows {
            for j in 0..other.cols {
                let mut sum = 0;
                for k in 0..self.cols {
                    sum += self.data[i][k] * other.data[k][j];
                }
                result.data[i][j] = sum;
            }
        }
        Ok(result)
    }

    fn serialize(&self, filename: &str) -> io::Result<()> {
        let mut file = File::create(filename)?;
        writeln!(file, "{} {}", self.rows, self.cols)?;
        for i in 0..self.rows {
            for j in 0..self.cols {
                write!(file, "{} ", int_to_ternary(self.data[i][j]))?;
            }
            writeln!(file)?;
        }
        Ok(())
    }

    fn deserialize(filename: &str) -> io::Result<TMatrix> {
        let file = File::open(filename)?;
        let reader = BufReader::new(file);
        let mut lines = reader.lines();
        let first_line = lines.next().ok_or_else(|| io::Error::new(io::ErrorKind::InvalidData, "empty file"))??;
        let dims: Vec<usize> = first_line.split_whitespace()
            .map(|s| s.parse().map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e)))
            .collect::<Result<_, _>>()?;
        if dims.len() != 2 { return Err(io::Error::new(io::ErrorKind::InvalidData, "invalid dimensions")); }
        let rows = dims[0];
        let cols = dims[1];
        let mut data = Vec::with_capacity(rows);
        for line in lines.take(rows) {
            let line = line?;
            let row: Vec<i32> = line.split_whitespace()
                .map(|s| parse_ternary(s).map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e)))
                .collect::<Result<_, _>>()?;
            if row.len() != cols { return Err(io::Error::new(io::ErrorKind::InvalidData, "row length mismatch")); }
            data.push(row);
        }
        if data.len() != rows { return Err(io::Error::new(io::ErrorKind::InvalidData, "insufficient rows")); }
        Ok(TMatrix { rows, cols, data })
    }
}

fn int_to_ternary(n: i32) -> String {
    if n == 0 { return "0".to_string(); }
    let mut digits = Vec::new();
    let mut num = n.abs();
    while num > 0 {
        digits.push((num % 3) as u8 + b'0');
        num /= 3;
    }
    if n < 0 { digits.push(b'-'); }
    String::from_utf8(digits.into_iter().rev().collect()).unwrap()
}

fn parse_ternary(s: &str) -> io::Result<i32> {
    let mut value = 0;
    let mut is_negative = false;
    let chars: Vec<char> = s.chars().collect();
    let mut i = 0;
    if chars.is_empty() { return Err(io::Error::new(io::ErrorKind::InvalidData, "empty ternary string")); }
    if chars[0] == '-' { is_negative = true; i += 1; }
    while i < chars.len() {
        let c = chars[i];
        if c < '0' || c > '2' { return Err(io::Error::new(io::ErrorKind::InvalidData, format!("invalid ternary digit '{}'", c))); }
        value = value * 3 + (c as i32 - '0' as i32);
        i += 1;
    }
    Ok(if is_negative { -value } else { value })
}

fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() < 2 {
        eprintln!("error: missing operation (add, mul, ser, des)");
        process::exit(1);
    }

    match args[1].as_str() {
        "add" => {
            if args.len() != 4 {
                eprintln!("error: usage: ternary-matrix add <file1> <file2>");
                process::exit(1);
            }
            let m1 = TMatrix::deserialize(&args[2]).unwrap_or_else(|e| {
                eprintln!("error: failed to read {}: {}", args[2], e);
                process::exit(1);
            });
            let m2 = TMatrix::deserialize(&args[3]).unwrap_or_else(|e| {
                eprintln!("error: failed to read {}: {}", args[3], e);
                process::exit(1);
            });
            let result = m1.add(&m2).unwrap_or_else(|e| {
                eprintln!("error: {}", e);
                process::exit(1);
            });
            result.serialize("/dev/stdout").unwrap_or_else(|e| {
                eprintln!("error: failed to write result: {}", e);
                process::exit(1);
            });
        }
        "mul" => {
            if args.len() != 4 {
                eprintln!("error: usage: ternary-matrix mul <file1> <file2>");
                process::exit(1);
            }
            let m1 = TMatrix::deserialize(&args[2]).unwrap_or_else(|e| {
                eprintln!("error: failed to read {}: {}", args[2], e);
                process::exit(1);
            });
            let m2 = TMatrix::deserialize(&args[3]).unwrap_or_else(|e| {
                eprintln!("error: failed to read {}: {}", args[3], e);
                process::exit(1);
            });
            let result = m1.multiply(&m2).unwrap_or_else(|e| {
                eprintln!("error: {}", e);
                process::exit(1);
            });
            result.serialize("/dev/stdout").unwrap_or_else(|e| {
                eprintln!("error: failed to write result: {}", e);
                process::exit(1);
            });
        }
        "ser" => {
            if args.len() != 3 {
                eprintln!("error: usage: ternary-matrix ser <output_file>");
                process::exit(1);
            }
            let mut input = String::new();
            io::stdin().lock().read_to_string(&mut input).unwrap_or_else(|e| {
                eprintln!("error: failed to read input: {}", e);
                process::exit(1);
            });
            let lines: Vec<&str> = input.lines().collect();
            if lines.len() < 1 {
                eprintln!("error: empty matrix input");
                process::exit(1);
            }
            let dims: Vec<usize> = lines[0].split_whitespace()
                .map(|s| s.parse().unwrap_or_else(|_| {
                    eprintln!("error: invalid dimensions");
                    process::exit(1);
                }))
                .collect();
            if dims.len() != 2 {
                eprintln!("error: invalid dimensions");
                process::exit(1);
            }
            let rows = dims[0];
            let cols = dims[1];
            let mut data = Vec::with_capacity(rows);
            for line in &lines[1..] {
                let row: Vec<i32> = line.split_whitespace()
                    .map(|s| parse_ternary(s).unwrap_or_else(|e| {
                        eprintln!("error: invalid matrix data: {}", e);
                        process::exit(1);
                    }))
                    .collect();
                if row.len() != cols {
                    eprintln!("error: row length mismatch");
                    process::exit(1);
                }
                data.push(row);
            }
            if data.len() != rows {
                eprintln!("error: insufficient rows");
                process::exit(1);
            }
            let matrix = TMatrix { rows, cols, data };
            matrix.serialize(&args[2]).unwrap_or_else(|e| {
                eprintln!("error: failed to write {}: {}", args[2], e);
                process::exit(1);
            });
        }
        "des" => {
            if args.len() != 3 {
                eprintln!("error: usage: ternary-matrix des <input_file>");
                process::exit(1);
            }
            let matrix = TMatrix::deserialize(&args[2]).unwrap_or_else(|e| {
                eprintln!("error: failed to read {}: {}", args[2], e);
                process::exit(1);
            });
            matrix.serialize("/dev/stdout").unwrap_or_else(|e| {
                eprintln!("error: failed to write output: {}", e);
                process::exit(1);
            });
        }
        _ => {
            eprintln!("error: unknown operation '{}'; use add, mul, ser, or des", args[1]);
            process::exit(1);
        }
    }
}
@*/

/*=====================================================================
  Ternary Opcode Tool: ternary-opcode.rs
  Encodes or validates a ternary opcode based on a flag and stdin input.
  Outputs encoded string or validation result to stdout.
=====================================================================*/
@* Ternary Opcode Tool: ternary-opcode.rs
@o ternary-opcode.rs
@c
use std::io::{self, BufRead, Write};
use std::env;
use std::process;

fn int_to_ternary(n: i32) -> String {
    if n == 0 { return "0".to_string(); }
    let mut digits = Vec::new();
    let mut num = n.abs();
    while num > 0 {
        digits.push((num % 3) as u8 + b'0');
        num /= 3;
    }
    if n < 0 { digits.push(b'-'); }
    String::from_utf8(digits.into_iter().rev().collect()).unwrap()
}

fn discrete_opcode_encode(opcode: i32) -> String {
    let ternary = int_to_ternary(opcode);
    let checksum = ternary.chars()
        .filter(|&c| c >= '0' && c <= '2')
        .map(|c| (c as u32 - '0' as u32) as i32)
        .sum::<i32>() % 3;
    format!("{}{}", ternary, checksum)
}

fn discrete_opcode_validate(encoded: &str) -> bool {
    if encoded.len() < 2 { return false; }
    let (code, checksum) = encoded.split_at(encoded.len() - 1);
    let checksum_digit = checksum.chars().next().unwrap();
    if checksum_digit < '0' || checksum_digit > '2' { return false; }
    let computed_sum = code.chars()
        .filter(|&c| c >= '0' && c <= '2')
        .map(|c| (c as u32 - '0' as u32) as i32)
        .sum::<i32>() % 3;
    computed_sum == (checksum_digit as u32 - '0' as u32) as i32
}

fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() < 2 {
        eprintln!("error: missing operation (encode or validate)");
        process::exit(1);
    }

    let stdin = io::stdin();
    let mut input = String::new();
    if let Err(e) = stdin.lock().read_line(&mut input) {
        eprintln!("error: failed to read input: {}", e);
        process::exit(1);
    }
    let input = input.trim();

    match args[1].as_str() {
        "encode" => {
            let opcode = input.parse::<i32>().unwrap_or_else(|_| {
                eprintln!("error: invalid integer input");
                process::exit(1);
            });
            let encoded = discrete_opcode_encode(opcode);
            if let Err(e) = writeln!(io::stdout(), "{}", encoded) {
                eprintln!("error: failed to write output: {}", e);
                process::exit(1);
            }
        }
        "validate" => {
            let valid = discrete_opcode_validate(input);
            if let Err(e) = writeln!(io::stdout(), "{}", if valid { "valid" } else { "invalid" }) {
                eprintln!("error: failed to write output: {}", e);
                process::exit(1);
            }
        }
        _ => {
            eprintln!("error: unknown operation '{}'; use encode or validate", args[1]);
            process::exit(1);
        }
    }
}
@*/

/*=====================================================================
  End of Ternary Tools Suite CWEB Document
=====================================================================*/
